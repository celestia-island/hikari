# Hikari i18n System

## Overview

The Hikari i18n system provides internationalization support for Hikari UI applications. It uses TOML files for language definitions and integrates seamlessly with Dioxus components.

## Features

- **Type-safe language keys** - Generated with `yuuka` for deep nested structures
- **TOML-based translations** - Easy to read and edit
- **Context-based access** - Use `use_i18n()` hook in any component
- **Language switcher component** - Ready-to-use UI for language selection
- **Multi-language support** - Built-in support for English, Simplified Chinese, and Traditional Chinese

## Quick Start

### 1. Define TOML Content

Create TOML files for each language:

```toml
# en-US.toml
[common.button]
submit = "Submit"
cancel = "Cancel"

[common.navigation]
home = "Home"
about = "About"
```

```toml
# zh-CN.toml
[common.button]
submit = "提交"
cancel = "取消"

[common.navigation]
home = "首页"
about = "关于"
```

### 2. Wrap App with I18nProvider

```rust
use hikari_i18n::{I18nProvider, context::Language};

fn App() -> Element {
    rsx! {
        I18nProvider {
            language: Language::English,
            toml_content: EN_US_TOML,
            YourApp {}
        }
    }
}
```

### 3. Use i18n in Components

```rust
use hikari_i18n::use_i18n;

fn MyComponent() -> Element {
    let i18n = use_i18n();

    rsx! {
        button { "{i18n.keys.common.button.submit}" }
        a { href: "/about", "{i18n.keys.common.navigation.about}" }
    }
}
```

## Language Switcher

The `LanguageSwitcher` component provides a ready-to-use UI for switching languages:

```rust
use hikari_i18n::{LanguageSwitcher, context::Language};

fn App() -> Element {
    let mut language = use_signal(|| Language::English);

    rsx! {
        LanguageSwitcher {
            current_language: language(),
            on_language_change: move |lang| language.set(lang),
        }
    }
}
```

## Supported Languages

| Language | Code | Enum Variant |
|----------|------|--------------|
| English | `en-US` | `Language::English` |
| Simplified Chinese | `zh-CN` | `Language::ChineseSimplified` |
| Traditional Chinese | `zh-TW` | `Language::ChineseTraditional` |

## Dynamic Language Loading

To load different languages dynamically:

```rust
fn App() -> Element {
    let mut language = use_signal(|| Language::English);

    let toml_content = match language() {
        Language::English => EN_US_TOML,
        Language::ChineseSimplified => ZH_CN_TOML,
        Language::ChineseTraditional => ZH_TW_TOML,
    };

    rsx! {
        I18nProvider {
            language: language(),
            toml_content,
            YourApp {}
        }
    }
}
```

## Complete Example

See `/examples/website/src/components/i18n_demo.rs` for a complete working example.

## API Reference

### Components

- `I18nProvider` - Root provider component
- `LanguageSwitcher` - Language selection UI

### Hooks

- `use_i18n()` - Access i18n context in components

### Types

- `Language` - Supported language enum
- `I18nContext` - Context containing language and keys
- `I18nKeys` - Language key structure

## Architecture

```
I18nProvider (root)
    ↓
use_context_provider
    ↓
I18nContext (accessible via use_i18n)
    ↓
i18n.keys.common.button.submit
```

## Best Practices

1. **Keep TOML files organized** - Use nested structures for related keys
2. **Use descriptive key names** - e.g., `common.button.submit` instead of `btn1`
3. **Provide all translations** - Ensure all keys exist in all language files
4. **Test language switching** - Verify all components update correctly when language changes

## Future Enhancements

- Support for more languages
- Pluralization rules
- Date/number formatting
- Lazy loading of language files
