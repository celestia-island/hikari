# hikari-builder

Build-time code generation and SCSS compilation for Hikari UI applications.

## Overview

`hikari-builder` provides:

- **SCSS Compilation** - Uses [Grass](https://github.com/kaj/kaj) (pure Rust Sass compiler) to compile SCSS to CSS
- **Component Discovery** - Automatically discovers components from SCSS files
- **Code Generation** - Generates Rust constants for discovered components
- **Asset Bundling** - Creates optimized CSS bundles for production
- **Zero External Dependencies** - No Ruby, Node.js, or build tools required

## Design Philosophy

This crate embraces **compile-time automation** to reduce manual configuration:

```rust
// build.rs - That's it!
fn main() {
    hikari_builder::build().expect("Build failed");
}
```

The build system:
1. **Finds** all SCSS component files
2. **Generates** Rust constants for discovered components
3. **Compiles** SCSS bundle using Grass
4. **Integrates** seamlessly with Cargo build process

## Installation

Add to your `Cargo.toml` as a build dependency:

```toml
[build-dependencies]
hikari-builder = "0.1.0"
```

## Usage

### Basic Usage

Add this to your `build.rs` file:

```rust,ignore
fn main() {
    hikari_builder::build().expect("Build failed");
}
```

That's it! The build system will:
- Scan `packages/components/src/styles/components/` for SCSS files
- Generate `packages/builder/src/generated/components.rs`
- Compile SCSS bundle to `public/styles/bundle.css`

### With Custom Configuration

For advanced use cases, use the `Builder` API:

```rust,ignore
use hikari_builder::{Builder, BuildConfig};

fn main() {
    let config = BuildConfig {
        components: vec![
            "button".to_string(),
            "input".to_string(),
            "card".to_string(),
        ],
        output_dir: "dist".into(),
        minify_css: true,
        ..BuildConfig::default()
    };

    Builder::new(config)
        .build()
        .expect("Build failed");
}
```

## Build Process

When you run `cargo build`, the build system executes these steps:

### 1. Find Workspace Root

```
üî® Hikari Builder starting...
üìÇ Workspace root: "/path/to/hikari"
```

The build system traverses up from `CARGO_MANIFEST_DIR` to locate the workspace root by finding `Cargo.toml` with `[workspace]` section.

### 2. Scan for SCSS Files

```
üìÑ Found 20 SCSS files
```

Searches `packages/components/src/styles/components/` and collects all `.scss` file names:
- `button.scss` ‚Üí component "button"
- `input.scss` ‚Üí component "input"
- `card.scss` ‚Üí component "card"
- etc.

### 3. Generate Rust Code

```
üìù Generated components.rs
```

Creates `packages/builder/src/generated/components.rs` with:

```rust,ignore
//! Auto-generated component list
//!
//! This file is generated by hikari-builder build script.
//! Do not edit manually.

use std::collections::HashSet;

/// List of available Hikari components
pub static AVAILABLE_COMPONENTS: &[&str] = &[
    "alert",
    "badge",
    "button",
    "card",
    "input",
    // ... more components
];

/// Get default set of components (all available)
pub fn default_components() -> HashSet<String> {
    AVAILABLE_COMPONENTS.iter().map(|s| s.to_string()).collect()
}
```

### 4. Compile SCSS Bundle

```
üé® Compiling SCSS with Grass...
   Entry point: "/path/to/hikari/packages/components/src/styles/index.scss"
‚úÖ CSS bundle generated: "/path/to/hikari/public/styles/bundle.css"
   Size: 45678 bytes
‚úÖ Hikari Builder completed!
```

Uses Grass (pure Rust Sass compiler) to compile the SCSS entry point and all imports.

## SCSS Compilation

### Why Grass?

- **No Ruby dependency** - Fully compiled, faster than Ruby Sass
- **No external tools** - Everything runs in the build process
- **Full SCSS support** - Variables, mixins, functions, imports
- **WASM compatible** - Can cross-compile for any target

### Entry Point Structure

The main entry point (`packages/components/src/styles/index.scss`) should import all component styles:

```scss
// Import theme variables
@use 'variables' as *;

// Import component styles
@use 'components/button';
@use 'components/input';
@use 'components/card';
@use 'components/alert';
@use 'components/badge';

// Import utility classes
@use 'utilities/display';
@use 'utilities/layout';
@use 'utilities/spacing';

// Import base styles
@use 'base';
```

### Component SCSS Files

Each component has its own SCSS file in `packages/components/src/styles/components/`:

```scss
// button.scss
.hi-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: var(--hi-spacing-sm) var(--hi-spacing-md);
    border-radius: var(--hi-radius-sm);

    // Variants
    &.hi-button-primary {
        background-color: var(--hi-color-primary);
        color: var(--hi-color-on-primary);
    }

    &.hi-button-secondary {
        background-color: var(--hi-color-secondary);
        color: var(--hi-color-on-secondary);
    }
}
```

## Build Configuration

### BuildConfig

Customize the build process with `BuildConfig`:

```rust,ignore
use hikari_builder::BuildConfig;

let config = BuildConfig {
    // Which components to include
    components: vec![
        "button".to_string(),
        "card".to_string(),
        "input".to_string(),
    ],

    // Where to write output files
    output_dir: "public".into(),

    // Project root directory
    project_root: ".".into(),

    // Minify CSS for production
    minify_css: false,

    // SCSS entry point
    scss_entry: "packages/components/src/styles/index.scss".into(),
};
```

### Configuration Options

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `components` | `Vec<String>` | `["button", "badge", ...]` | Components to include |
| `output_dir` | `PathBuf` | `"public"` | CSS output directory |
| `project_root` | `PathBuf` | `"."` | Project root directory |
| `minify_css` | `bool` | `false` | Minify CSS output |
| `scss_entry` | `PathBuf` | `"packages/components/src/styles/index.scss"` | SCSS entry point |

### Default Configuration

```rust
impl Default for BuildConfig {
    fn default() -> Self {
        Self {
            components: vec![
                "button".to_string(),
                "badge".to_string(),
                "card".to_string(),
                "input".to_string(),
                "alert".to_string(),
                "toast".to_string(),
                "tooltip".to_string(),
            ],
            output_dir: "public".into(),
            project_root: ".".into(),
            minify_css: false,
            scss_entry: "packages/components/src/styles/index.scss".into(),
        }
    }
}
```

## Output Files

The build system generates these files:

| File | Description |
|------|-------------|
| `packages/builder/src/generated/components.rs` | Rust constants for components |
| `public/styles/bundle.css` | Compiled CSS bundle |
| `public/styles/` | Output directory for all CSS |

## Using Generated Code

### In Your Application

```rust
use hikari_builder::generated::components;

// Get all available components
let all = components::AVAILABLE_COMPONENTS;
println!("Available components: {:?}", all);

// Get default component set
let defaults = components::default_components();
assert!(defaults.contains("button"));
```

### With Style Registry

```rust
use hikari_components::StyleRegistry;
use hikari_builder::generated::components;

let mut registry = StyleRegistry::default();

// Register all discovered components
for component in components::AVAILABLE_COMPONENTS {
    registry.register(component, &format!("/styles/{}.css", component));
}

// Or register default set
let defaults = components::default_components();
registry.register_multiple(&defaults);
```

## Build Output Example

During compilation, you'll see build progress:

```text
   Compiling hikari-builder v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 1.23s
     Running hikari-builder build script...
cargo:warning=üî® Hikari Builder starting...
cargo:warning=üìÇ Workspace root: "/path/to/hikari"
cargo:warning=üìÑ Found 20 SCSS files
cargo:warning=üìù Generated components.rs
cargo:warning=üé® Compiling SCSS with Grass...
cargo:warning=   Entry point: "/path/to/hikari/packages/components/src/styles/index.scss"
cargo:warning=‚úÖ CSS bundle generated: "/path/to/hikari/public/styles/bundle.css"
cargo:warning=   Size: 45678 bytes
cargo:warning=‚úÖ Hikari Builder completed!
    Finished dev [unoptimized + debuginfo] target(s) in 3.45s
```

## Integration with Cargo

The build system integrates seamlessly with Cargo's build process:

### Automatic Builds

1. Runs automatically during `cargo build`
2. Tracks SCSS file changes for rebuilds
3. Outputs warnings for build progress
4. Fails compilation if SCSS has errors

### Incremental Builds

- **First build**: ~2-5 seconds (SCSS compilation)
- **Incremental builds**: <1 second (if SCSS unchanged)
- **Parallel builds**: Supported (one build per workspace member)

### Rebuild Triggers

The build system rebuilds when:
- SCSS files change
- `build.rs` changes
- `BuildConfig` changes
- Workspace structure changes

## Error Handling

The build system returns detailed errors:

```rust,ignore
match hikari_builder::build() {
    Ok(_) => println!("Build successful"),
    Err(e) => eprintln!("Build failed: {}", e),
}
```

### Common Errors

#### `index.scss not found`

**Cause**: SCSS entry point path is incorrect

**Solution**: Check that `packages/components/src/styles/index.scss` exists

```rust,ignore
let config = BuildConfig {
    scss_entry: "packages/components/src/styles/index.scss".into(),
    //                                    ^^^^^^^^^^^^^^^^
    //                                    Verify this path is correct
    ..Default::default()
};
```

#### `SCSS compilation failed`

**Cause**: SCSS syntax error

**Solution**: Fix SCSS syntax errors in component files

```scss
// ‚ùå BAD - Missing semicolon
.hi-button {
    display: inline-flex
}

// ‚úÖ GOOD - Correct syntax
.hi-button {
    display: inline-flex;
}
```

#### `Invalid workspace root`

**Cause**: No `[workspace]` section found in `Cargo.toml`

**Solution**: Ensure workspace has proper `Cargo.toml`:

```toml
[workspace]
members = [
    "packages/components",
    "packages/builder",
    # ...
]
```

## API Reference

### `build()`

Main entry point for the build process.

```rust
pub fn build() -> anyhow::Result<()>
```

**Errors**:
- Workspace root cannot be found
- SCSS files cannot be read
- Code generation fails
- SCSS compilation fails

**Example**:
```rust,ignore
fn main() {
    hikari_builder::build().expect("Build failed");
}
```

### `Builder`

Fluent builder API for custom build configurations.

```rust
pub struct Builder {
    config: BuildConfig,
}

impl Builder {
    pub fn new(config: BuildConfig) -> anyhow::Result<Self>;

    pub fn build(&self) -> anyhow::Result<()>;
}
```

**Example**:
```rust,ignore
use hikari_builder::Builder;

Builder::new(config)
    .build()
    .expect("Build failed");
```

### `BuildConfig`

Build configuration structure.

```rust
pub struct BuildConfig {
    pub components: Vec<String>,
    pub output_dir: PathBuf,
    pub project_root: PathBuf,
    pub minify_css: bool,
    pub scss_entry: PathBuf,
}
```

## Performance

### Build Times

| Scenario | Time |
|----------|------|
| First build (cold) | ~2-5 seconds |
| Incremental (no SCSS changes) | <1 second |
| Incremental (SCSS changes) | ~2-3 seconds |

### Optimization Tips

1. **Use selective components** - Only include components you use
2. **Enable minification** for production builds
3. **Cache CSS** - Use browser caching for `bundle.css`
4. **Parallel builds** - Build multiple workspace members in parallel

```rust,ignore
// Production configuration
let config = BuildConfig {
    components: vec!["button".into(), "card".into()], // Only what you need
    minify_css: true, // Enable minification
    ..Default::default()
};
```

## Platform Support

- ‚úÖ **Linux** - Fully supported
- ‚úÖ **macOS** - Fully supported
- ‚úÖ **Windows** - Fully supported
- ‚úÖ **WASM** - Can cross-compile for WASM target

## Integration with Other Hikari Crates

### hikari-components

```rust
use hikari_components::StyleRegistry;
use hikari_builder::generated::components;

let mut registry = StyleRegistry::default();
registry.register_available(); // Uses generated constants
```

### hikari-theme

```scss
// In SCSS files
@use 'hikari-theme' as *;

// Variables are available
.hi-button {
    background-color: var(--hi-color-primary);
}
```

### hikari-render-service

```rust,ignore
// The render-service automatically uses the compiled CSS bundle
let app = HikariRenderServicePlugin::new()
    .static_assets("./public", "/static")
    .build()?;
```

## Examples

### Minimal build.rs

```rust,ignore
fn main() {
    hikari_builder::build().expect("Build failed");
}
```

### Custom component selection

```rust,ignore
use hikari_builder::{Builder, BuildConfig};

fn main() {
    let config = BuildConfig {
        components: vec![
            "button".to_string(),
            "input".to_string(),
        ],
        ..Default::default()
    };

    Builder::new(config)
        .build()
        .expect("Build failed");
}
```

### Production build with minification

```rust,ignore
use hikari_builder::{Builder, BuildConfig};

fn main() {
    let config = BuildConfig {
        minify_css: true,
        ..Default::default()
    };

    Builder::new(config)
        .build()
        .expect("Build failed");
}
```

## License

MIT OR Apache-2.0

## Acknowledgments

- [Grass](https://github.com/kaj/kaj) - Pure Rust Sass compiler
- [Dioxus](https://dioxuslabs.com/) - Reactive GUI framework for Rust
