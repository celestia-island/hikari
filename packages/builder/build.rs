//! Build script for Hikari UI applications
//!
//! This build script:
//! 1. Scans for SCSS files in the project
//! 2. Generates Rust constants for discovered components
//! 3. Compiles SCSS to CSS bundle using Grass
//!
//! # Usage
//!
//! Add to your project's build.rs:
//! ```rust,ignore
//! fn main() {
//!     hikari_builder::build().expect("Build failed");
//! }
//! ```

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Main build function
pub fn build() -> anyhow::Result<()> {
    println!("cargo:warning=üî® Hikari Builder starting...");

    // Get workspace root
    let workspace_root = env::var("CARGO_MANIFEST_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("."));

    // Find workspace root (go up until we find Cargo.toml with workspace members)
    let workspace_root = find_workspace_root(&workspace_root);

    println!("cargo:warning=üìÇ Workspace root: {:?}", workspace_root);

    // Scan for SCSS files
    let scss_files = scan_scss_files(&workspace_root)?;
    println!("cargo:warning=üìÑ Found {} SCSS files", scss_files.len());

    // Track all SCSS files for rebuild detection
    for scss_file in &scss_files {
        println!("cargo:rerun-if-changed={}", scss_file);
    }

    // Also track key SCSS directories to catch new files
    let scss_dirs = [
        "packages/components/src/styles",
        "packages/theme/styles",
        "examples/demo-app/src/styles",
    ];
    for dir in &scss_dirs {
        let full_path = workspace_root.join(dir);
        if full_path.exists() {
            println!("cargo:rerun-if-changed={}", full_path.display());
        }
    }

    // Generate Rust constants
    let generated_dir = workspace_root.join("packages/builder/src/generated");
    fs::create_dir_all(&generated_dir)?;

    generate_component_constants(&generated_dir, &scss_files)?;

    // Compile SCSS bundle
    compile_scss_bundle(&workspace_root)?;

    println!("cargo:warning=‚úÖ Hikari Builder completed!");

    Ok(())
}

/// Find the workspace root by looking for Cargo.toml with [workspace]
fn find_workspace_root(start: &Path) -> PathBuf {
    let mut current = start;

    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists() {
            if let Ok(content) = fs::read_to_string(&cargo_toml) {
                if content.contains("[workspace]") {
                    return current.to_path_buf();
                }
            }
        }

        match current.parent() {
            Some(parent) if parent != current => {
                current = parent;
            }
            _ => return start.to_path_buf(),
        }
    }
}

/// Scan for all SCSS files in the project
fn scan_scss_files(workspace_root: &Path) -> anyhow::Result<Vec<String>> {
    let mut scss_files = Vec::new();

    // Scan packages/components/src/styles/components/
    let components_dir = workspace_root.join("packages/components/src/styles/components");
    if components_dir.exists() {
        let entries = fs::read_dir(&components_dir)?;
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("scss") {
                if let Some(file_name) = path.file_stem().and_then(|s| s.to_str()) {
                    scss_files.push(file_name.to_string());
                }
            }
        }
    }

    scss_files.sort();
    Ok(scss_files)
}

/// Generate Rust constants for discovered components
fn generate_component_constants(output_dir: &Path, components: &[String]) -> anyhow::Result<()> {
    let mut content = String::from(
        r#"//! Auto-generated component list
//!
//! This file is generated by hikari-builder build script.
//! Do not edit manually.

use std::collections::HashSet;

/// List of available Hikari components
pub static AVAILABLE_COMPONENTS: &[&str] = &[
"#,
    );

    for component in components {
        content.push_str(&format!("    \"{}\",\n", component));
    }

    content.push_str(
        r#"];

/// Get default set of components (all available)
pub fn default_components() -> HashSet<String> {
    AVAILABLE_COMPONENTS.iter().map(|s| s.to_string()).collect()
}
"#,
    );

    fs::write(output_dir.join("components.rs"), content)?;
    println!("cargo:warning=üìù Generated components.rs");

    Ok(())
}

/// Compile SCSS to CSS bundle using Grass (Rust Sass compiler)
fn compile_scss_bundle(workspace_root: &Path) -> anyhow::Result<()> {
    println!("cargo:warning=üé® Compiling SCSS with Grass...");

    // Use index.scss as entry point (has @import for all components)
    let index_scss = workspace_root.join("packages/components/src/styles/index.scss");
    if !index_scss.exists() {
        return Err(anyhow::anyhow!("index.scss not found at {:?}", index_scss));
    }

    println!("cargo:warning=   Entry point: {:?}", index_scss);

    // Prepare output path
    let output_dir = workspace_root.join("public/styles");
    fs::create_dir_all(&output_dir)?;
    let css_output = output_dir.join("bundle.css");

    // Delete existing bundle to prevent cache issues
    if css_output.exists() {
        fs::remove_file(&css_output)?;
        println!("cargo:warning=üóëÔ∏è  Removed old bundle.css");
    }

    // Compile with Grass - it will handle @import and @use resolution automatically
    let css_content = grass::from_path(&index_scss, &grass::Options::default())
        .map_err(|e| anyhow::anyhow!("SCSS compilation failed: {:?}", e))?;

    // Get file size
    let file_size = css_content.len();

    // Write to output
    fs::write(&css_output, css_content.clone())?;

    // Verify file was written
    if css_output.exists() {
        println!("cargo:warning=‚úÖ CSS bundle generated: {:?}", css_output);
        println!("cargo:warning=   Size: {} bytes", file_size);
        println!(
            "cargo:warning=   Verified: File exists at {:?}",
            css_output.canonicalize()
        );
    } else {
        return Err(anyhow::anyhow!(
            "CSS bundle was not created at {:?}",
            css_output
        ));
    }

    Ok(())
}

fn main() {
    if let Err(e) = build() {
        eprintln!("‚ùå Build failed: {}", e);
        std::process::exit(1);
    }
}
