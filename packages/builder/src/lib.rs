//! Hikari Builder - Build system for Hikari UI applications
//!
//! This crate provides build utilities for Hikari UI applications, including:
//! - SCSS compilation using Grass (Rust Sass compiler)
//! - Component selection and bundling
//! - Static asset generation
//!
//! # Usage in build.rs
//!
//! ```rust,ignore
//! fn main() {
//!     hikari_builder::build().expect("Build failed");
//! }
//! ```

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Main build function - compiles SCSS and generates components
pub fn build() -> anyhow::Result<()> {
    println!("cargo:warning=ðŸ”¨ Hikari Builder starting...");

    // Get workspace root
    let workspace_root = env::var("CARGO_MANIFEST_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| PathBuf::from("."));

    // Find workspace root (go up until we find Cargo.toml with workspace members)
    let workspace_root = find_workspace_root(&workspace_root);

    println!("cargo:warning=ðŸ“‚ Workspace root: {:?}", workspace_root);

    // Scan for SCSS files
    let scss_files = scan_scss_files(&workspace_root)?;
    println!("cargo:warning=ðŸ“„ Found {} SCSS files", scss_files.len());

    // Generate Rust constants
    let generated_dir = workspace_root.join("packages/builder/src/generated");
    fs::create_dir_all(&generated_dir)?;

    generate_component_constants(&generated_dir, &scss_files)?;

    // Compile SCSS bundle
    compile_scss_bundle(&workspace_root)?;

    println!("cargo:warning=âœ… Hikari Builder completed!");

    Ok(())
}

/// Find the workspace root by looking for Cargo.toml with [workspace]
fn find_workspace_root(start: &Path) -> PathBuf {
    let mut current = start;

    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists() {
            if let Ok(content) = fs::read_to_string(&cargo_toml) {
                if content.contains("[workspace]") {
                    return current.to_path_buf();
                }
            }
        }

        match current.parent() {
            Some(parent) if parent != current => {
                current = parent;
            }
            _ => return start.to_path_buf(),
        }
    }
}

/// Scan for all SCSS files in the project
fn scan_scss_files(workspace_root: &Path) -> anyhow::Result<Vec<String>> {
    let mut scss_files = Vec::new();

    // Scan packages/components/src/styles/components/
    let components_dir = workspace_root.join("packages/components/src/styles/components");
    if components_dir.exists() {
        let entries = fs::read_dir(&components_dir)?;
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("scss") {
                if let Some(file_name) = path.file_stem().and_then(|s| s.to_str()) {
                    scss_files.push(file_name.to_string());
                }
            }
        }
    }

    scss_files.sort();
    Ok(scss_files)
}

/// Generate Rust constants for discovered components
fn generate_component_constants(
    output_dir: &Path,
    components: &[String],
) -> anyhow::Result<()> {
    let mut content = String::from(
        r#"//! Auto-generated component list
//!
//! This file is generated by hikari-builder build script.
//! Do not edit manually.

use std::collections::HashSet;

/// List of available Hikari components
pub static AVAILABLE_COMPONENTS: &[&str] = &[
"#,
    );

    for component in components {
        content.push_str(&format!("    \"{}\",\n", component));
    }

    content.push_str(
        r#"];

/// Get default set of components (all available)
pub fn default_components() -> HashSet<String> {
    AVAILABLE_COMPONENTS.iter().map(|s| s.to_string()).collect()
}
"#,
    );

    fs::write(output_dir.join("components.rs"), content)?;
    println!("cargo:warning=ðŸ“ Generated components.rs");

    Ok(())
}

/// Compile SCSS to CSS bundle using Grass (Rust Sass compiler)
fn compile_scss_bundle(workspace_root: &Path) -> anyhow::Result<()> {
    println!("cargo:warning=ðŸŽ¨ Compiling SCSS with Grass...");

    // Use index.scss as entry point (has @import for all components)
    let index_scss = workspace_root.join("packages/components/src/styles/index.scss");
    if !index_scss.exists() {
        return Err(anyhow::anyhow!("index.scss not found at {:?}", index_scss));
    }

    println!("cargo:warning=   Entry point: {:?}", index_scss);

    // Compile with Grass - it will handle @import and @use resolution automatically
    let css_content = grass::from_path(
        &index_scss,
        &grass::Options::default(),
    ).map_err(|e| anyhow::anyhow!("SCSS compilation failed: {:?}", e))?;

    // Get file size
    let file_size = css_content.len();

    // Write to output directory
    let output_dir = workspace_root.join("public/styles");
    fs::create_dir_all(&output_dir)?;

    let css_output = output_dir.join("bundle.css");
    fs::write(&css_output, css_content)?;

    println!("cargo:warning=âœ… CSS bundle generated: {:?}", css_output);
    println!("cargo:warning=   Size: {} bytes", file_size);

    Ok(())
}

/// Build configuration
#[derive(Clone, Debug)]
pub struct BuildConfig {
    /// Enabled components (e.g., ["button", "badge", "card"])
    pub components: Vec<String>,

    /// Output directory (default: "public")
    pub output_dir: PathBuf,

    /// Project root directory (default: current directory)
    pub project_root: PathBuf,

    /// Whether to minify CSS (default: false)
    pub minify_css: bool,

    /// SCSS entry point (default: "packages/components/src/styles/index.scss")
    pub scss_entry: PathBuf,
}

impl Default for BuildConfig {
    fn default() -> Self {
        Self {
            components: vec![
                "button".to_string(),
                "badge".to_string(),
                "card".to_string(),
                "input".to_string(),
                "alert".to_string(),
                "toast".to_string(),
                "tooltip".to_string(),
            ],
            output_dir: "public".into(),
            project_root: ".".into(),
            minify_css: false,
            scss_entry: "packages/components/src/styles/index.scss".into(),
        }
    }
}

/// Builder for Hikari UI applications
pub struct Builder {
    config: BuildConfig,
}

impl Builder {
    /// Create a new builder with the given configuration
    pub fn new(config: BuildConfig) -> anyhow::Result<Self> {
        Ok(Self { config })
    }

    /// Build the project
    pub fn build(&self) -> anyhow::Result<()> {
        // Ensure output directory exists
        std::fs::create_dir_all(&self.config.output_dir)?;

        // Note: SCSS compilation is handled by build.rs
        println!("âœ… Build configuration prepared");

        Ok(())
    }
}
